/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package io.lantern.tassis

import com.google.protobuf.ByteString
import com.google.protobuf.GeneratedMessageLite
import java.nio.ByteBuffer
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.atomic.AtomicInteger

/**
 * Represents an error from tassis
 */
class TassisError(val name: String, val description: String) : Exception("${name}: ${description}")

/**
 * Callback interface for receiving asynchronous results.
 */
interface Callback<T> {
    fun onSuccess(result: T)

    fun onError(err: Throwable)
}

/**
 * A handler for messages received from a transport (e.g. a websocket connection)
 */
interface MessageHandler {
    /**
     * Called whenever a new message arrives from the remote end
     */
    fun onMessage(data: ByteBuffer?)

    /**
     * Called when the transport has been closed to let the MessageHandler know that it should close
     * too. If the transport was closed due to an error condition, err will be populated.
     */
    fun onClose(err: Throwable? = null)
}

/**
 * A facility for sending messages (e.g. a websocket connection)
 */
interface Transport {
    fun setHandler(handler: MessageHandler)

    fun send(data: ByteArray)

    fun close()
}

/**
 * A factory for Transports.
 */
interface TransportFactory {
    fun build(cb: Callback<Transport>)
}

/**
 * Represents an inbound message from another user. Call ack() once the message has been durably
 * recorded so that it can be deleted server-side.
 */
class InboundMessage internal constructor(private val msg: Messages.Message, private val client: AuthenticatedClient) {
    val data: ByteString
        get() = msg.inboundMessage

    fun ack() {
        client.send(Messages.Message.newBuilder().setSequence(msg.sequence).setAck(Messages.Ack.newBuilder().build()).build())
    }
}

/**
 * A delegate for receiving lifecycle callbacks from a Client connection.
 */
interface ClientDelegate {
    /**
     * Called when a client closes. If the client closed due to an exception, err will be populated
     * with the relevant exception.
     */
    fun onClose(err: Throwable? = null)
}

/**
 * A delegate for receiving asynchronous callbacks on an authenticated client connection.
 */
interface AuthenticatedClientDelegate : ClientDelegate {
    /**
     * Called when AuthChallenge is received. Should generate the corresponding AuthResponse to
     * complete the authentication.
     */
    fun authenticate(challenge: Messages.AuthChallenge): Messages.AuthResponse

    /**
     * Called when tassis notifies us that one-time pre keys are getting low.
     */
    fun onPreKeysLow(msg: Messages.PreKeysLow)

    /**
     * Called when we receive an inbound message from another user device via tassis.
     */
    fun onInboundMessage(msg: InboundMessage)
}

/**
 * Client provides a mechanism for talking to a tassis service.
 */
abstract class Client<D : ClientDelegate>(private val transport: Transport, protected val delegate: D) : MessageHandler {
    private val msgSequence = AtomicInteger()
    protected val pending = ConcurrentHashMap<Int, Callback<Any?>>()

    init {
        transport.setHandler(this)
    }

    protected fun send(detail: GeneratedMessageLite<*, *>, callback: Callback<*>? = null) {
        val msg = buildMessage(detail)
        if (callback != null) {
            pending[msg.sequence] = callback as Callback<Any?>
        }
        send(msg)
    }

    internal fun send(msg: Messages.Message) {
        transport.send(msg.toByteArray())
    }

    private fun buildMessage(detail: GeneratedMessageLite<*, *>): Messages.Message {
        val msg = Messages.Message.newBuilder()
        when (detail) {
            is Messages.AuthResponse -> msg.authResponse = detail
            is Messages.Register -> msg.register = detail
            is Messages.Unregister -> msg.unregister = detail
            is Messages.RequestPreKeys -> msg.requestPreKeys = detail
            is Messages.OutboundMessage -> msg.outboundMessage = detail
            else -> throw Exception("attempted to send unknown message type ${msg.javaClass.name}")
        }
        return msg.build()
    }

    override fun onMessage(data: ByteBuffer?) {
        val msg = Messages.Message.parseFrom(data)
        when (msg.payloadCase) {
            Messages.Message.PayloadCase.ACK -> pending[msg.sequence]?.onSuccess(null)
            Messages.Message.PayloadCase.ERROR -> pending[msg.sequence]?.onError(TassisError(msg.error!!.name, msg.error!!.description))
            else -> println("unknown payload type ${msg.payloadCase}")
        }
    }

    fun close() {
        transport.close()
    }

    override fun onClose(err: Throwable?) {
        pending.clear()
        delegate.onClose(err)
    }
}

/**
 * Authenticated client is a Client that has authenticated against the tassis cluster and can be
 * used for operations that require authentication.
 */
class AuthenticatedClient private constructor(transport: Transport,
                                              delegate: AuthenticatedClientDelegate,
                                              private val connectCallback: Callback<AuthenticatedClient>) : Client<AuthenticatedClientDelegate>(transport, delegate) {
    private val wrappedConnectCallback = object : Callback<Void?> {
        override fun onSuccess(result: Void?) {
            connectCallback.onSuccess(this@AuthenticatedClient)
        }

        override fun onError(err: Throwable) {
            connectCallback.onError(err)
            close() // don't report error again since we already reported it to the callback
        }
    }

    fun register(registrationID: Int, signedPreKey: ByteArray, oneTimePreKeys: Iterable<ByteArray>, callback: Callback<Void>) {
        val msg = Messages.Register.newBuilder()
                .setRegistrationID(registrationID)
                .setSignedPreKey(ByteString.copyFrom(signedPreKey))
                .addAllOneTimePreKeys(oneTimePreKeys.map { ByteString.copyFrom(it) })
        send(msg.build(), callback)
    }

    fun unregister(callback: Callback<Void>) {
        send(Messages.Unregister.newBuilder().build(), callback)
    }

    override fun onMessage(data: ByteBuffer?) {
        val msg = Messages.Message.parseFrom(data)
        when (msg.payloadCase) {
            Messages.Message.PayloadCase.AUTHCHALLENGE -> send(delegate.authenticate(msg.authChallenge), wrappedConnectCallback)
            Messages.Message.PayloadCase.PREKEYS -> pending[msg.sequence]?.onSuccess(msg.preKeys)
            Messages.Message.PayloadCase.PREKEYSLOW -> delegate.onPreKeysLow(msg.preKeysLow)
            Messages.Message.PayloadCase.INBOUNDMESSAGE -> delegate.onInboundMessage(InboundMessage(msg, this))
            else -> super.onMessage(data)
        }
    }

    companion object {
        /**
         * Connects an AuthenticatedClient using the given transportFactory.
         */
        fun connect(transportFactory: TransportFactory,
                    delegate: AuthenticatedClientDelegate,
                    connectCallback: Callback<AuthenticatedClient>) {
            transportFactory.build(object : Callback<Transport> {
                override fun onSuccess(result: Transport) {
                    AuthenticatedClient(result, delegate, connectCallback)
                }

                override fun onError(err: Throwable) {
                    connectCallback.onError(err)
                }
            })
        }
    }
}

/**
 * Anonymous client is a client that does not authenticate against the tassis service. It is used
 * for anonymous operations like requesting pre keys and sending sealed sender messages.
 */
class AnonymousClient private constructor(transport: Transport,
                                          delegate: ClientDelegate,
                                          private val connectCallback: Callback<AnonymousClient>) : Client<ClientDelegate>(transport, delegate) {
    fun requestPreKeys(userID: ByteArray, knownDeviceIDs: Iterable<Int>, callback: Callback<Messages.PreKeys>) {
        val msg = Messages.RequestPreKeys.newBuilder()
                .setUserID(ByteString.copyFrom(userID))
                .addAllKnownDeviceIDs(knownDeviceIDs)
        send(msg.build(), callback)
    }

    fun sendUserMessage(userID: ByteArray, deviceID: Int, message: ByteArray, callback: Callback<Void>) {
        val msg = Messages.OutboundMessage.newBuilder()
                .setTo(Messages.Address.newBuilder().setUserID(ByteString.copyFrom(userID)).setDeviceID(deviceID).build())
                .setUnidentifiedSenderMessage(ByteString.copyFrom(message))
        send(msg.build(), callback)
    }

    override fun onMessage(data: ByteBuffer?) {
        val msg = Messages.Message.parseFrom(data)
        when (msg.payloadCase) {
            Messages.Message.PayloadCase.AUTHCHALLENGE -> connectCallback.onSuccess(this)
            Messages.Message.PayloadCase.PREKEYS -> pending[msg.sequence]?.onSuccess(msg.preKeys)
            else -> super.onMessage(data)
        }
    }

    companion object {
        /**
         * Connects an AnonymousClient using the given transportFactory.
         */
        fun connect(transportFactory: TransportFactory,
                    delegate: ClientDelegate,
                    connectCallback: Callback<AnonymousClient>) {
            transportFactory.build(object : Callback<Transport> {
                override fun onSuccess(result: Transport) {
                    AnonymousClient(result, delegate, connectCallback)
                }

                override fun onError(err: Throwable) {
                    connectCallback.onError(err)
                }
            })
        }
    }
}