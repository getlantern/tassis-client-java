/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package io.lantern.tassis

import com.google.protobuf.ByteString
import kotlinx.coroutines.*
import kotlinx.coroutines.channels.Channel
import java.nio.ByteBuffer
import java.nio.charset.Charset
import java.util.concurrent.atomic.AtomicInteger
import kotlin.test.Test
import kotlin.test.assertEquals
import kotlin.test.assertNull

class ClientTest {
    @Test
    fun testAuthenticationError() {
        val factory = InMemoryTransportFactory(false)
        try {
            val h = TestHelper(factory.coroutineScope)
            val delegate = Delegate("user1", 100, "signature1", h)

            AuthenticatedClient.connect(factory, delegate, h.expectError())

            runBlocking(Dispatchers.Unconfined) {
                val error = h.errorChannel.receive()
                assertEquals("login_failure: ", error?.message)
            }
        } finally {
            factory.close(null)
        }
    }

    @Test
    fun testAuthenticatedFlow() {
        val factory = InMemoryTransportFactory(true)
        try {
            val h = TestHelper(factory.coroutineScope)
            val delegate = Delegate("user1", 100, "signature1", h)

            AuthenticatedClient.connect(factory, delegate, h.expectSuccess())

            runBlocking(Dispatchers.Unconfined) {
                val client = h.successChannel.receive() as AuthenticatedClient

                client.register(100, "pk".toByteArray(Charset.defaultCharset()), listOf("otpk1".toByteArray(Charset.defaultCharset()), "otpk2".toByteArray(Charset.defaultCharset())), h.expectSuccess())
                factory.ack()
                h.successChannel.receive()

                client.unregister(h.expectSuccess())
                factory.ack()
                h.successChannel.receive()

                factory.respond(Messages.Message.newBuilder()
                        .setSequence(-1)
                        .setInboundMessage(ByteString.copyFromUtf8("inbound message")))
                val inboundMsg = h.successChannel.receive() as InboundMessage
                assertEquals("inbound message", inboundMsg.data.toStringUtf8())
                inboundMsg.ack()

                factory.respond(Messages.Message.newBuilder()
                        .setSequence(-1)
                        .setPreKeysLow(Messages.PreKeysLow.newBuilder()
                                .setKeysRequested(50).build()))
                val preKeysLow = h.successChannel.receive() as Messages.PreKeysLow
                assertEquals(50, preKeysLow.keysRequested)

                assertEquals(delegate.signature, factory.sentMessages[0].authResponse.signature.toStringUtf8())
                assertEquals(delegate.userID, Messages.Login.parseFrom(factory.sentMessages[0].authResponse.login).address.userID.toStringUtf8())
                assertEquals(delegate.deviceID, Messages.Login.parseFrom(factory.sentMessages[0].authResponse.login).address.deviceID)
                assertEquals(100, factory.sentMessages[1].register.registrationID)
                assertEquals("pk", factory.sentMessages[1].register.signedPreKey.toStringUtf8())
                assertEquals("otpk1", factory.sentMessages[1].register.getOneTimePreKeys(0).toStringUtf8())
                assertEquals("otpk2", factory.sentMessages[1].register.getOneTimePreKeys(1).toStringUtf8())
                assert(factory.sentMessages[2].hasUnregister())
                assert(factory.sentMessages[3].hasAck())

                factory.close(Exception("closed for error"))
                assertEquals("closed for error", h.errorChannel.receive()?.message)
            }
        } finally {
            factory.close(null)
        }
    }

//    @Test
    fun testAnonymous() {
        val factory = InMemoryTransportFactory(true)
        try {
            val h = TestHelper(factory.coroutineScope)
            val delegate = Delegate("user1", 100, "signature1", h)

            AnonymousClient.connect(factory, delegate, h.expectSuccess())

            runBlocking(Dispatchers.Unconfined) {
                val client = h.successChannel.receive() as AnonymousClient
                client.requestPreKeys("userA".toByteArray(Charset.defaultCharset()), listOf(1, 2), h.expectSuccess())
                factory.respond(Messages.Message.newBuilder()
                        .setPreKeys(Messages.PreKeys.newBuilder()
                                .addPreKeys(Messages.PreKey.newBuilder()
                                        .setAddress(Messages.Address.newBuilder()
                                                .setUserID(ByteString.copyFromUtf8("userA"))
                                                .setDeviceID(3).build())
                                        .setSignedPreKey(ByteString.copyFromUtf8("pk"))
                                        .setOneTimePreKey(ByteString.copyFromUtf8("otpk1")).build())))
                val msg = h.successChannel.receive() as Messages.PreKeys
                val preKeys = msg.preKeysList
                assertEquals(1, preKeys.size)
                if (preKeys.size > 0) {
                    val preKey = preKeys[0]
                    assertEquals("userA", preKey.address.userID.toStringUtf8())
                    assertEquals("pk", preKey.signedPreKey.toStringUtf8())
                    assertEquals("otpk1", preKey.oneTimePreKey.toStringUtf8())
                }

                assertEquals("userA", factory.sentMessages[0].requestPreKeys.userID.toStringUtf8())

                factory.close(null)
                assertNull(h.errorChannel.receive())
            }
        } finally {
            factory.close(null)
        }
    }

    @Test
    fun testFailingTransportBuildAuthenticated() {
        val factory = FailingTransportFactory()
        val h = TestHelper(GlobalScope)
        val delegate = Delegate("user1", 100, "signature1", h)

        AuthenticatedClient.connect(factory, delegate, h.expectError())

        runBlocking(Dispatchers.Unconfined) {
            assertEquals("won't build", h.errorChannel.receive()?.message)
        }
    }

    @Test
    fun testFailingTransportBuildAnonymous() {
        val factory = FailingTransportFactory()
        val h = TestHelper(GlobalScope)
        val delegate = Delegate("user1", 100, "signature1", h)

        AnonymousClient.connect(factory, delegate, h.expectError())

        runBlocking(Dispatchers.Default) {
            assertEquals("won't build", h.errorChannel.receive()?.message)
        }
    }
}

private class TestHelper(internal val coroutineScope: CoroutineScope) {
    val successChannel = Channel<Any?>()
    val errorChannel = Channel<Throwable?>()

    fun <T> expectSuccess(): Callback<T> {
        return object : Callback<T> {
            override fun onSuccess(result: T) {
                coroutineScope.launch {
                    successChannel.send(result)
                }
            }

            override fun onError(err: Throwable) {
                successChannel.close(err)
            }
        }
    }

    fun <T> expectError(): Callback<T> {
        return object : Callback<T> {
            override fun onSuccess(result: T) {
                successChannel.close(Exception("Unexpected success ${result}"))
            }

            override fun onError(err: Throwable) {
                coroutineScope.launch {
                    errorChannel.send(err)
                }
            }
        }
    }
}

private class Delegate(val userID: String, val deviceID: Int, val signature: String, val h: TestHelper) : AuthenticatedClientDelegate {
    override fun authenticate(challenge: Messages.AuthChallenge): Messages.AuthResponse {
        return Messages.AuthResponse.newBuilder()
                .setLogin(Messages.Login.newBuilder()
                        .setNonce(challenge.nonce)
                        .setAddress(Messages.Address.newBuilder()
                                .setUserID(ByteString.copyFromUtf8(userID))
                                .setDeviceID(deviceID)).build().toByteString())
                .setSignature(ByteString.copyFromUtf8(signature)).build()
    }

    override fun onPreKeysLow(msg: Messages.PreKeysLow) {
        h.coroutineScope.launch {
            h.successChannel.send(msg)
        }
    }

    override fun onInboundMessage(msg: InboundMessage) {
        h.coroutineScope.launch {
            h.successChannel.send(msg)
        }
    }

    override fun onClose(err: Throwable?) {
        h.coroutineScope.launch {
            h.errorChannel.send(err)
        }
    }
}

private class InMemoryTransport(val factory: InMemoryTransportFactory) : Transport {
    override fun send(data: ByteArray) {
        val msg = Messages.Message.parseFrom(data)
        factory.sentMessages.add(msg)
        if (msg.hasAuthResponse()) {
            if (factory.succeedOnLogin) {
                factory.ack()
            } else {
                factory.error("login_failure")
            }
        }
    }

    override fun setHandler(handler: MessageHandler) {
        factory.handler = handler

        val sequenceNumber = AtomicInteger()
        factory.coroutineScope.launch {
            factory.responses.send(Messages.Message.newBuilder()
                    .setSequence(-1)
                    .setAuthChallenge(
                            Messages.AuthChallenge.newBuilder()
                                    .setNonce(ByteString.copyFromUtf8("authnonce"))))
            for (msg in factory.responses) {
                if (msg.sequence < 0) {
                    msg.sequence = sequenceNumber.getAndIncrement()
                }
                handler.onMessage(ByteBuffer.wrap(msg.build().toByteArray()))
            }
            factory.coroutineScope.cancel()
        }
    }

    override fun close() {
        factory.responses.close()
    }
}

private class InMemoryTransportFactory(val succeedOnLogin: Boolean) : TransportFactory {
    val coroutineScope = CoroutineScope(Dispatchers.Default)
    val sentMessages = ArrayList<Messages.Message>()
    val responses = Channel<Messages.Message.Builder>(100)
    var handler: MessageHandler? = null

    fun ack() {
        respond(Messages.Message.newBuilder()
                .setAck(Messages.Ack.newBuilder().build())
                .setSequence(sentMessages.last().sequence))
    }

    fun error(name: String) {
        respond(Messages.Message.newBuilder()
                .setError(Messages.Error.newBuilder().setName(name).build())
                .setSequence(sentMessages.last().sequence))
    }

    fun respond(msg: Messages.Message.Builder) {
        coroutineScope.launch {
            responses.send(msg)
        }
    }

    override fun build(cb: Callback<Transport>) {
        cb.onSuccess(InMemoryTransport(this))
    }

    fun close(err: Throwable?) {
        responses.close()
        handler?.onClose(err)
        handler = null
    }
}

private class FailingTransportFactory() : TransportFactory {
    override fun build(cb: Callback<Transport>) {
        cb.onError(Exception("won't build"))
    }
}